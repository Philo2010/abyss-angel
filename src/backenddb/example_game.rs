//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.17
use schemars::JsonSchema;
use sea_orm::{ActiveValue::{NotSet, Set}, EntityOrSelect, ExprTrait, QuerySelect, entity::prelude::*, sea_query::{Alias, Func, Mode}};
use serde::{Deserialize, Serialize};
use crate::{backenddb::game::{self, GamesAvg, GamesAvgSpecific, GamesEditSpecific, GamesFull, GamesFullSpecific, GamesGraph, GamesGraphSpecific, GamesInserts, GamesInsertsSpecific, NormalSpcDataAvg, YearOp}, entity::genertic_header};
use abyss_macro::enum_builder_variant;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, JsonSchema)]
#[sea_orm(table_name = "example_game")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,

    pub hehe: i32,
    pub beep: i32,
    pub hoohoo: String,
}

pub const YEAR: i32 = 9999;


fn get_total_score(hehe: i32, beep: i32) -> i32 {
        hehe * 6 + beep * 7
}

pub struct Functions;

//                                                             Game Type ID>↓.     ↓<Game Id

#[async_trait]
impl YearOp for Functions {
    fn get_year_id(&self) -> i32 {
        YEAR
    }
    async fn insert(&self, data: &GamesInsertsSpecific, db: &DatabaseConnection) -> Result<(i32, i32, i32), DbErr> {
        match &data {
            GamesInsertsSpecific::ExampleGame(a) => {
                let game_db: ActiveModel = ActiveModel { 
                    id: NotSet, 
                    hehe: Set(a.hehe), 
                    beep: Set(a.beep), 
                    hoohoo: Set(a.hoohoo.clone())
                };
                Ok((YEAR, Entity::insert(game_db).exec(db).await?.last_insert_id, get_total_score(a.hehe, a.beep)))
            },
            _ => {
                Err(DbErr::AttrNotSet("This is invaild type for the current year!".to_string()))
            }
        }
    }

    async fn graph(&self, ids: Vec<i32>, db: &DatabaseConnection) -> Result<Vec<GamesGraphSpecific>, DbErr> {
        let mut entries = Entity::find()
            .filter(Column::Id.is_in(ids.clone()))
            .all(db).await?; //TODO Op info
        
        entries.sort_by_key(|entry| {
            ids.iter().position(|id| *id == entry.id).unwrap_or(usize::MAX)
        });

        let enume: Vec<GamesGraphSpecific> = entries.iter().map(|x| {
            GamesGraphSpecific::ExampleGame(Graph { 
                hehe: x.hehe,
                beep: x.beep })
        }).collect();


        Ok(enume)
    }

    async fn average_team(&self, ids: Vec<(i32, Vec<i32>)>, db: &DatabaseConnection) -> Result<Vec<(i32, GamesAvgSpecific)>, DbErr> {
        //todo
        todo!()
    }


    async fn get_full_matches(&self, ids: Vec<i32>, db: &DatabaseConnection) -> Result<Vec<game::GamesFullSpecific>, DbErr> {
        match Entity::find()
            .filter(Column::Id.is_in(ids.clone()))
            .all(db).await {
                Ok(mut a) => {
                    a.sort_by_key(|entry| {
                        ids.iter().position(|id| *id == entry.id).unwrap_or(usize::MAX)
                    });
                    Ok(a.into_iter().map(|x| {
                        GamesFullSpecific::ExampleGame(x)
                    }).collect())
                },
                Err(a) => {Err(a)},
            }
    }
    
    async fn delete(&self, id: i32, db: &DatabaseConnection) -> Result<(), DbErr> {
        Entity::delete_by_id(id).exec(db).await?;

        Ok(())
    }
    
    async fn get(&self, id: i32, db: &DatabaseConnection) -> Result<GamesFullSpecific, DbErr> {
        let res = Entity::find_by_id(id).one(db).await?;
        match res {
            Some(a) => Ok(GamesFullSpecific::ExampleGame(a)),
            None => Err(DbErr::RecordNotFound("Could not find".to_string())),
        }
    }
    
    async fn edit(&self, mut header: genertic_header::ActiveModel, edit: GamesEditSpecific, db: &DatabaseConnection) -> Result<(), DbErr> {
        //get total score
        //We unwrap as if called from the correct funcsion game_id should be set
        let id_to_unfuck_rust = header.game_id.clone();
        let total_score = Entity::find_by_id(id_to_unfuck_rust.unwrap()).one(db).await?.ok_or(DbErr::RecordNotFound("Could not find game data to edit!".to_string()))?;
        
        let am = match edit {
            GamesEditSpecific::ExampleGame(a) => {
                let hehe = a.hehe.unwrap_or(total_score.hehe);
                let beep = a.beep.unwrap_or(total_score.beep);
                let score = get_total_score(hehe, beep);
                header.total_score = Set(score);
                let header_data = header.insert(db).await?;

                ActiveModel {
                    id: Set(header_data.game_id), 
                    hehe: a.hehe.map(Set).unwrap_or(NotSet),
                    beep: a.beep.map(Set).unwrap_or(NotSet),
                    hoohoo: a.hoohoo.map(Set).unwrap_or(NotSet)
                }
            }
            _ => {
                return Err(DbErr::AttrNotSet("Wrong game!".to_string()));
            }
        };

        let res = am.update(db).await?;

        Ok(())
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

//Structures for sending between

pub struct Insert {
    pub hehe: i32,
    pub beep: i32,
    pub hoohoo: String
}

pub struct Edit {
    pub hehe: Option<i32>,
    pub beep: Option<i32>,
    pub hoohoo: Option<String>
}


#[derive(Serialize, JsonSchema)]
pub struct Graph {
    //Per game
    pub hehe: i32,
    pub beep: i32,
}



#[derive(Serialize, JsonSchema)]
pub struct Avg {
    pub hehe_avg: f32,
    pub beep_avg: f32,
}

//Full is just the Model

//Search only needs an output of full
//Delete just is a enum of checking how good we are doing
//Get only needs a genetric insert
//Edit can resute insert
